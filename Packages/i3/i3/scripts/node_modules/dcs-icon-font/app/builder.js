'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.build = undefined;

var _webfontsGenerator = require('webfonts-generator');

var _webfontsGenerator2 = _interopRequireDefault(_webfontsGenerator);

var _glob = require('glob');

var _glob2 = _interopRequireDefault(_glob);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Responsible for the generation of the icon font
 * @param  {Object} config - an object containing all the needed options for the webfont generator.
 * @return {Object} a successful response or an error in case it occurs
 */
function build() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // if it is a --help access
  if (config.customOpts && config.customOpts.help) {
    return Promise.resolve('\nThese are all the available arguments:\n--out [String]: specifies where the generated code is stored into. Default "./build"\n--icons [String]: specifies the directory that contains the SVG icons for which you want to generate the font. Default "./icons"\n--fontname [String]: the name for your brand new font. Default "dcsIconFont"\n--baseSelector [String]: specifies the base css class name. Default "dcs-icon"\n--cssFontsUrl [String]: the font URL to be defined into the resulting CSS file. Default: the --fontname specified\n--cssDest [String]: the destination path for the resulting CSS file. Default: The --out specified\n--classprefix [String]: specifies the css class prefix for all your icons. Default "dcs-icon-"\n--html: enables the generation of a html file with a preview for all the icons in the generated font\n--sass: generates a SCSS file instead of a CSS file\n--htmlTemplate: for providing a custom HTML template\n--cssTemplate: for providing a custom CSS template\n--scssTemplate: for providing a custom SCSS template\n    ');
  }

  return setWebFontOptions(config).then(function (options) {
    return generateDcsIconFont(options);
  }).then(function () {
    return Promise.resolve({ success: true });
  }).catch(function (e) {
    throw e;
  });
}

/**
 * Responsible for evaluating the provided arguments (config) and, if valid,
 * set up the options for the webfont generator
 * @param {Object} config the configurations provided by the user through CLI arguments
 */
function setWebFontOptions(config) {
  return new Promise(function (resolve, reject) {
    try {
      var iconsPath = config.customOpts.icons || 'icons/*.svg';
      var files = _glob2.default.sync(iconsPath);

      if (!files.length) {
        reject(new Error('"' + iconsPath + '" does not match any SVG file. It must be something similar to "your-path/*.svg"'));
      }

      if (config.customOpts.sass && config.customOpts.html) {
        reject(new Error('Is not possible to generate a HTML preview for SASS outputs'));
      }

      var options = Object.assign({}, config.webfontsOptions);
      options.files = files;

      resolve(options);
    } catch (e) {
      reject(e);
    }
  });
}

/**
 * Responsible for triggering the generation of the font
 * @param  {Object} webfontsOptions the options for the webfont generator
 * @return {Object} a promise with the result of the generation
 */
function generateDcsIconFont(webfontsOptions) {
  return new Promise(function (resolve, reject) {
    (0, _webfontsGenerator2.default)(webfontsOptions, function (error, result) {
      if (error) {
        reject(error);
      }

      resolve({ success: true, result: result });
    });
  });
}

exports.build = build;